Here is a complete project implementation plan to build the "Sentinel Support" system as specified.

This plan breaks the project into logical milestones, starting from the data foundation and moving up through the stack to the agent orchestration and final evaluation.

üöÄ 1. Project Overview & Architecture
You are building a case-resolution console where a support agent can load customer activity, get AI-generated insights, and run a multi-agent triage that recommends and executes safe actions, with explainable traces, policy guardrails, and observability.

High-Level Architecture (ASCII)
This stack is designed for local-first execution, type-safety, and clear separation of concerns.

Code snippet

[ User (Support Agent) ]
       |
[ web (React + TS + Vite) ] <--- (SSE / HTTP) ---> [ api (Node + Express + TS) ]
       |                                                    |
       +----------------------------------------------------+
       |
 [ Docker Compose ]
   |
   +-- [ postgres (Data) ]  <-- (Prisma/TypeORM) --- [ api ]
   |     - Customers
   |     - Transactions (Indexed)
   |     - Cases / Audits
   |     - Traces
   |
   +-- [ redis (Cache/Queue) ] <-- (ioredis) -------- [ api ]
   |     - Rate Limiting (Token Bucket)
   |     - Triage Job/Stream Channel
   |
   +-- [ api (Node.js) ]
   |     - REST/SSE Server
   |     - Orchestrator
   |     - Sub-Agents
   |
   +-- [ web (React) ]
         - Static Files (CSR)
üó∫Ô∏è 2. Step-by-Step Implementation Plan
Milestone 0: Setup, Schema & Seeding
Goal: Establish the monorepo, database, and CI/CD basics.

Monorepo: Initialize a monorepo (e.g., using pnpm workspaces or just /api, /web folders).

Docker: Create the docker-compose.yml to spin up postgres, redis, api, and web.

Database (Prisma):

Define the exact schema from Section 3 in schema.prisma.

Run prisma migrate dev to generate and apply the initial SQL migration.

Fixtures & Seeding:

Create /fixtures and add the JSON files (customers.json, kb_docs.json, etc.).

Create /scripts/seed.ts (using prisma.$transaction for bulk inserts) to load all fixtures except transactions.

Create /scripts/generate_txns.ts. This script must:

Accept a count n (e.g., npm run gen:txns -- 1000000).

Generate realistic data (valid MCCs, merchant names, amounts).

Write to transactions.json in batches (or stream to POST /api/ingest).

Seed the DB with 200k transactions initially.

Milestone 1: Backend - Core Data APIs (The "Read" Path)
Goal: Build the foundational, high-performance APIs for reading customer data.

Core APIs (Express/Fastify):

GET /health, GET /metrics (with prom-client stubs).

POST /api/ingest/transactions: Implements upsert and deduplication on (customerId, txnId). Must handle the Idempotency-Key header.

Performance-Critical Endpoint:

GET /api/customer/:id/transactions:

Pagination: Must use keyset pagination (not offset). The cursor will be based on (ts, id).

Query: ...WHERE customer_id = $1 AND (ts, id) < ($cursor_ts, $cursor_id) ORDER BY ts DESC, id DESC LIMIT $limit.

Indexing: Verify the composite index (customer_id, ts DESC) is used (via EXPLAIN ANALYZE). This is critical for the p95 ‚â§ 100ms SLO.

Insights & KB APIs:

GET /api/insights/:customerId/summary: Build the deterministic fallback first. This involves SQL queries: GROUP BY category, GROUP BY merchant, date_trunc('month', ts).

GET /api/kb/search?q=: Simple SQL LIKE or to_tsvector query on the kb_docs table.

Milestone 2: Frontend - The "Read" Views
Goal: Build the React UI for agents to view customer data.

Setup: npx vite@latest web --template react-ts. Add Tailwind, react-router-dom.

Routing: Implement all routes (/dashboard, /alerts, /customer/:id, /evals).

Customer Timeline (/customer/:id):

Fetch data from /api/customer/:id/transactions and /api/insights/:customerId/summary.

Performance: Use tanstack-virtual (or react-window) for the transaction list to handle ‚â•2k rows without jank.

Implement infinite scroll using the nextCursor from the API.

Memoize row components (React.memo).

Alerts & Dashboard:

/alerts: A simple paginated table (using tanstack-table) fetching from /fixtures/alerts.json (or a new /api/alerts endpoint). Each row has an "Open Triage" button.

/dashboard: Stubbed KPI charts.

Milestone 3: Backend - Multi-Agent System (The "Brain")
Goal: Implement the server-side orchestration, sub-agents, and guardrails.

Sub-Agents (as deterministic functions):

InsightsAgent: Runs the SQL queries from Milestone 1. (Optional: If USE_LLM=true, pipes the JSON result to an LLM for phrasing).

FraudAgent: A pure function that takes transactions and returns {score, reasons[]} based on deterministic rules (velocity, MCC rarity, etc.).

KBAgent: Runs the SQL query from Milestone 1.

RedactorAgent: A utility class with a regex /\b(\d{13,19})\b/g to replace PANs with ****REDACTED****.

ComplianceAgent: Checks rules (e.g., if (action === 'freeze') return { otpRequired: true }).

Orchestrator (The "Planner"):

This will be an async function runTriage(alertId).

It will store results in agent_traces (steps, duration, I/O).

Plan: Hard-code the default plan: ["getProfile", "recentTx", "riskSignals", ...].

Guardrails: Wrap each agent call with:

Timeout: Promise.race with a setTimeout.

Retries: Use p-retry or a simple loop with exponential backoff + jitter.

Circuit Breaker: Use opossum to wrap critical tools (like the FraudAgent).

Validation: Use zod to parse the output of each agent, logging an error/using a fallback on schema mismatch.

PII & Logging:

Implement structured JSON logging (e.g., pino).

Create a pino formatter that automatically runs the RedactorAgent on all log message fields to ensure no PII is ever logged (Acceptance Scenario 6).

Milestone 4: Backend - The "Action" & Streaming APIs
Goal: Connect the "brain" (Triage) and "hands" (Actions) to the API layer.

Triage Streaming API:

POST /api/triage: Creates a triage_runs entry, starts runTriage(alertId) in the background (do not await), and returns { runId }.

GET /api/triage/:runId/stream: This is the SSE endpoint.

Use a technology like Redis Pub/Sub. The runTriage function publishes events (sse.dispatch('tool_update', data)) to a channel (e.g., triage:${runId}).

This endpoint subscribes to that Redis channel and pipes messages to the client.

This handles reconnects and scales horizontally.

Action Endpoints:

POST /api/action/freeze-card, POST /api/action/open-dispute.

Idempotency: Implement the Idempotency-Key check (store key -> result in Redis with a short TTL).

Audit Log: Crucially, create a middleware or decorator that wraps these action endpoints. After the action succeeds, it must write to the case_events table (who, what, when, redacted payload).

Cross-Cutting Concerns:

Rate Limiting: Add express-rate-limit (using rate-limit-redis) to apply a token bucket limit (5 r/s) to all mutation APIs. This will correctly return 429 with Retry-After.

Security: Add helmet for CSP headers. Add a simple API key middleware.

Milestone 5: Frontend - The "Hero" Triage Drawer
Goal: Build the interactive Triage UI that streams results and executes actions.

Component: Build the TriageDrawer (using radix-ui/react-dialog for a11y).

Data Flow:

On "Open Triage" click:

POST /api/triage -> get { runId }.

Initialize an EventSource: const sse = new EventSource('/api/triage/' + runId + '/stream').

sse.onmessage = (event) => { ... }: Parse the event (plan_built, tool_update, etc.) and update React state.

Accessibility (A11y):

Implement focus trap within the drawer.

ESC key must close it; focus must return to the "Open Triage" button.

Use aria-live="polite" for a region that announces streamed updates (e.g., "Risk analysis complete. Recommendation: Freeze Card.").

Action Buttons:

Wire up "Freeze Card," "Open Dispute" buttons to the Milestone 4 APIs.

Handle the PENDING_OTP flow (show an OTP input).

Handle 429 errors by disabling the buttons and showing a "Please wait..." message based on the Retry-After header.

Milestone 6: Evals, Observability & Deployment
Goal: Verify correctness, measure performance, and package the application.

Observability:

Metrics: Instrument all required metrics from Section 8 using prom-client (e.g., api_request_latency_ms, tool_call_total).

Logs: Ensure structured JSON logs are being produced for all key events.

Evals CLI (npm run eval):

Create /scripts/eval.ts.

This script will:

Load all /fixtures/evals/*.json files.

For each file, POST /api/triage (simulating the user input/alert).

Connect to the SSE stream and wait for the decision_finalized event.

Compare the resulting { risk, action, fallback_used } against the expected block in the JSON.

Compile stats (success rate, confusion matrix, latencies) and print the report (Section 9).

Performance Test (Acceptance Scenario 7):

Run npm run gen:txns -- 1000000 and seed the DB.

Use k6, artillery, or a simple bash loop to hit GET /api/customer/:id/transactions?last=90d 1000 times.

Measure the p95 latency.

Capture the EXPLAIN ANALYZE output for the query and add it to the README.md.

Docker: Build final Dockerfiles for api and web (using multi-stage builds) and test the full docker compose up --build flow.

üèõÔ∏è 3. Key Architectural Decisions (for ADR.md)
Why Prisma? For rapid development, end-to-end type-safety (FE to DB), and a clean migration workflow. Its upsert and transactional capabilities are perfect for /api/ingest.

Why Keyset Pagination? To meet the p95 <= 100ms SLO on 1M+ rows. OFFSET pagination gets progressively slower (O(N)), while keyset (cursor) pagination is stable (O(log N) or O(1) on an index).

Why Server-Sent Events (SSE)? Simpler, more reliable, and lower-overhead than WebSockets for this read-only server-to-client stream. SSE is just HTTP and supports automatic reconnection out-of-the-box.

Why Redis? Serves two distinct, critical roles: (1) Rate Limiting (centralized token bucket state) and (2) Streaming/Queueing (using Pub/Sub as a simple, reliable message bus for the detached triage-to-SSE stream).

Why Deterministic Fallbacks? This is a core safety requirement. The system must function without an LLM (local/offline). All agents (Fraud, Insights, Summarizer) are built "rules-first," with the LLM as an optional enhancement for phrasing, not for core logic.

Why a Background Triage Process? The POST /api/triage call must be non-blocking and return in <50ms. The agent orchestration (which can take up to 5s) runs after the request is complete, publishing its progress to Redis. This prevents HTTP request timeouts and supports a responsive UI.

Why Zod Schema Validation? To enforce the "contract" between agents. If the FraudAgent output schema changes, zod will catch it immediately at runtime, allowing the orchestrator to trigger a fallback instead of crashing or passing corrupt data downstream.

Why Structured JSON Logging? Essential for observability and audit. It allows us to grep for runId, customerId_masked, or event="action_completed" in a log aggregator (like Splunk/Datadog) and makes PII redaction (via a custom formatter) more reliable.

‚úÖ 4. Acceptance & Evaluation Plan
This plan will be verified exactly against these scenarios.

Freeze w/ OTP: Test by (1) clicking "Freeze", (2) seeing the ComplianceAgent requires OTP, (3) entering OTP, (4) verifying case_events shows the action.

Dispute Creation: Test with a specific transaction. Verify POST /api/action/open-dispute is called with the correct txnId and reasonCode (proposed by the FraudAgent).

Duplicate Txn: Manually ingest a PENDING and CAPTURED txn. Run triage. Verify the KBAgent finds the "preauth vs capture" doc and the final recommendation is not to dispute.

Risk Tool Fallback: Add a if (process.env.TEST_FAIL) throw new Error() to the FraudAgent. Run triage. Verify the SSE stream fires fallback_triggered and the UI shows risk_unavailable.

429 Behavior: Use k6 or a bash loop (for i in {1..10}; do curl ...; done) to spam POST /api/triage. Verify 429 Too Many Requests is returned and the FE UI correctly disables the button.

PII Redaction: Use the UI to submit a note with "My card 4111222233334444 was...". Verify the agent_traces table in Postgres and the console JSON logs both show ****REDACTED****.

Performance: Run the 1M row test (Milestone 6) and paste the k6 p95 result and EXPLAIN ANALYZE snippet into the README.

Evals CLI: Run npm run eval and paste the full CLI output into eval-report.md.

üì¶ 5. Deliverables Checklist
[ ] Monorepo: /api, /web, /fixtures, /scripts, /docs folders.

[ ] Docker Compose: docker-compose.yml with postgres, redis, api, web.

[ ] README.md: Includes 3-command setup, ASCII architecture diagram, and performance test results.

[ ] ADR.md: Contains the 8 decisions from Section 3.

[ ] Postman/HTTP Collection: sentinel-support.json file.

[ ] Demo Video (‚â§8 min): Shows all 7 acceptance scenarios.

[ ] Eval Report: Output from the npm run eval CLI.